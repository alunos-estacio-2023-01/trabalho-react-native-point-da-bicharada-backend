// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: client.sql

package pgstore

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/phenpessoa/br"
)

const createClient = `-- name: CreateClient :one
INSERT INTO clientes ("cpf", "nome", "endereco", "email")
VALUES ($1, $2, $3, $4)
RETURNING id
`

type CreateClientParams struct {
	Cpf      br.CPF
	Nome     string
	Endereco string
	Email    string
}

func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) (int64, error) {
	row := q.db.QueryRow(ctx, createClient,
		arg.Cpf,
		arg.Nome,
		arg.Endereco,
		arg.Email,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

type CreateClientPetsParams struct {
	ClienteID int64
	Nome      string
	Raca      string
	Especie   string
}

type CreateClientPhonesParams struct {
	ClienteID int64
	Telefone  string
}

const deleteClient = `-- name: DeleteClient :one
WITH deleted_rows AS (
    DELETE FROM clientes
    WHERE cpf = $1
    RETURNING 1
)
SELECT COUNT(*) AS count FROM deleted_rows
`

func (q *Queries) DeleteClient(ctx context.Context, cpf br.CPF) (int64, error) {
	row := q.db.QueryRow(ctx, deleteClient, cpf)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getClient = `-- name: GetClient :one
SELECT id, cpf, nome, endereco, email FROM clientes c
WHERE c.cpf = $1
`

func (q *Queries) GetClient(ctx context.Context, cpf br.CPF) (Cliente, error) {
	row := q.db.QueryRow(ctx, getClient, cpf)
	var i Cliente
	err := row.Scan(
		&i.ID,
		&i.Cpf,
		&i.Nome,
		&i.Endereco,
		&i.Email,
	)
	return i, err
}

const getClientPets = `-- name: GetClientPets :many
SELECT id, cliente_id, nome, raca, especie FROM clientes_pets WHERE cliente_id = $1
`

func (q *Queries) GetClientPets(ctx context.Context, clienteID int64) ([]ClientesPet, error) {
	rows, err := q.db.Query(ctx, getClientPets, clienteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ClientesPet
	for rows.Next() {
		var i ClientesPet
		if err := rows.Scan(
			&i.ID,
			&i.ClienteID,
			&i.Nome,
			&i.Raca,
			&i.Especie,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClientPhones = `-- name: GetClientPhones :many
SELECT telefone FROM clientes_telefones WHERE cliente_id = $1
`

func (q *Queries) GetClientPhones(ctx context.Context, clienteID int64) ([]string, error) {
	rows, err := q.db.Query(ctx, getClientPhones, clienteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var telefone string
		if err := rows.Scan(&telefone); err != nil {
			return nil, err
		}
		items = append(items, telefone)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getClients = `-- name: GetClients :many
SELECT id, cpf, nome, endereco, email FROM clientes c
`

func (q *Queries) GetClients(ctx context.Context) ([]Cliente, error) {
	rows, err := q.db.Query(ctx, getClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cliente
	for rows.Next() {
		var i Cliente
		if err := rows.Scan(
			&i.ID,
			&i.Cpf,
			&i.Nome,
			&i.Endereco,
			&i.Email,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCliente = `-- name: UpdateCliente :one
UPDATE clientes
SET
    nome = COALESCE($2, nome),
    email = COALESCE($3, email),
    endereco = COALESCE($4, endereco)
WHERE cpf = $1
RETURNING 1
`

type UpdateClienteParams struct {
	Cpf      br.CPF
	Nome     pgtype.Text
	Email    pgtype.Text
	Endereco pgtype.Text
}

func (q *Queries) UpdateCliente(ctx context.Context, arg UpdateClienteParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateCliente,
		arg.Cpf,
		arg.Nome,
		arg.Email,
		arg.Endereco,
	)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const updateClientePets = `-- name: UpdateClientePets :one
WITH id AS (
    SELECT id FROM clientes WHERE cpf = $1
),
deleted_rows AS (
    DELETE FROM clientes_pets
    WHERE EXISTS (SELECT id FROM id)
      AND cliente_id = (SELECT id FROM id LIMIT 1)
    RETURNING 1
),
inserted_rows AS (
    INSERT INTO clientes_pets (cliente_id, nome, raca, especie)
    SELECT id, unnest($2::text[]), unnest($3::text[]), unnest($4::text[])
    FROM id
    WHERE EXISTS (SELECT 1 FROM id)
)
SELECT EXISTS (SELECT 1 FROM id) AS success
`

type UpdateClientePetsParams struct {
	Cpf      br.CPF
	Nomes    []string
	Racas    []string
	Especies []string
}

func (q *Queries) UpdateClientePets(ctx context.Context, arg UpdateClientePetsParams) (bool, error) {
	row := q.db.QueryRow(ctx, updateClientePets,
		arg.Cpf,
		arg.Nomes,
		arg.Racas,
		arg.Especies,
	)
	var success bool
	err := row.Scan(&success)
	return success, err
}

const updateClientePhones = `-- name: UpdateClientePhones :one
WITH id AS (
    SELECT id FROM clientes WHERE cpf = $1
),
deleted_rows AS (
    DELETE FROM clientes_telefones
    WHERE EXISTS (SELECT id FROM id)
        AND cliente_id = (SELECT id FROM id LIMIT 1)
        AND telefone NOT IN (SELECT unnest($2::text[]))
    RETURNING 1
),
inserted_rows AS (
    INSERT INTO clientes_telefones (cliente_id, telefone)
    SELECT id, unnest($2::text[])
    FROM id
    WHERE EXISTS (SELECT 1 FROM id)
    ON CONFLICT (cliente_id, telefone) DO NOTHING
)
SELECT EXISTS (SELECT 1 FROM id) AS success
`

type UpdateClientePhonesParams struct {
	Cpf       br.CPF
	Telefones []string
}

func (q *Queries) UpdateClientePhones(ctx context.Context, arg UpdateClientePhonesParams) (bool, error) {
	row := q.db.QueryRow(ctx, updateClientePhones, arg.Cpf, arg.Telefones)
	var success bool
	err := row.Scan(&success)
	return success, err
}
